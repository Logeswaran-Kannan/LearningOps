import requests
import pandas as pd

# Token and URL Setup
token = "test"
url = "https://adb-67779643136828772.12.azuredatabricks.net/api/2.0/lineage-tracking/column-lineage"
headers = {
    "Authorization": f"Bearer {token}",
    "Content-Type": "application/json"
}

# List of columns to check
columns_to_check = ["productcode", "hash_diff"]

source_schema = "ods_views"
source_table = "vw_policycenter_std001_current_pc_policy"

all_lineage = []
summary_stats = []

for column in columns_to_check:
    print(f"\nProcessing lineage for column: {column}\n")

    # Parameters Setup
    params = {
        "table_name": f"core_tst_std001.{source_schema}.{source_table}",
        "column_name": column,
        "include_entity_lineage": True
    }

    # Request Execution
    response = requests.get(url, headers=headers, params=params)

    # Response Handling
    if response.status_code == 200:
        data = response.json()

        # Flatten the JSON if needed
        upstream = pd.json_normalize(data.get('upstream_cols', []))
        downstream = pd.json_normalize(data.get('downstream_cols', []))

        # Add direction and column being processed
        upstream["direction"] = "upstream"
        downstream["direction"] = "downstream"
        upstream["source_column"] = column
        downstream["source_column"] = column
        upstream["source_schema"] = source_schema
        upstream["source_table"] = source_table
        downstream["source_schema"] = source_schema
        downstream["source_table"] = source_table

        # Function to determine linkage type and comment
        def determine_linkage(row):
            col_name = row.get("name", "").lower()
            if col_name == column.lower():
                return pd.Series(["direct", f"Column '{column}' is directly used in this table/view"])
            else:
                return pd.Series(["indirect", f"Column is derived using '{column}' or other input columns"])

        # Apply linkage logic
        upstream[["linkage_type", "comment"]] = upstream.apply(determine_linkage, axis=1)
        downstream[["linkage_type", "comment"]] = downstream.apply(determine_linkage, axis=1)

        # Merge and collect
        lineage_df = pd.concat([upstream, downstream], ignore_index=True)
        all_lineage.append(lineage_df)

        # Summary statistics including downstream
        combined = pd.concat([upstream, downstream], ignore_index=True)
        upstream_count = upstream.shape[0]
        downstream_count = downstream.shape[0]
        distinct_col_count = combined['name'].nunique()
        distinct_tbl_count = combined['table_name'].nunique()
        direct_count = combined[combined['linkage_type'] == 'direct'].shape[0]
        indirect_count = combined[combined['linkage_type'] == 'indirect'].shape[0]

        summary_stats.append({
            "source_schema": source_schema,
            "source_table": source_table,
            "source_column": column,
            "upstream_count": upstream_count,
            "downstream_count": downstream_count,
            "total_distinct_column_count": distinct_col_count,
            "total_distinct_table_count": distinct_tbl_count,
            "direct_linkage_count": direct_count,
            "indirect_linkage_count": indirect_count
        })

    else:
        print(f"Request failed for column {column} with status code {response.status_code}")
        print(response.text)

# Combine all collected lineage info
if all_lineage:
    final_df = pd.concat(all_lineage, ignore_index=True)
    print("\nFinal Lineage Details (with linkage type and comments):\n")
    display(final_df)

    # Display summary statistics
    summary_df = pd.DataFrame(summary_stats)
    print("\nSummary Statistics per Column:\n")
    display(summary_df)
