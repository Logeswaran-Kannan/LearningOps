from pyspark.sql import SparkSession
from pyspark.sql.functions import col, when, lower
from pyspark.sql.types import StructType, StructField, StringType, IntegerType, ArrayType
from pyspark.sql.utils import AnalysisException
from concurrent.futures import ThreadPoolExecutor

# Initialize Spark session
spark = SparkSession.builder.appName("AutomatedValidation").getOrCreate()

# Catalog and database details
source_catalog = "core_tst_sys9"
source_db = "rr_source"
target_catalog = "core_tst_std001"
target_db = "ods"

# Table names to process (expandable)
table_names = ["ptable1", "btable2", "ctable3"]

# Date range for filtering
filter_start = '2025-05-12T00:00:01.0025+00:00'
filter_end = '2025-05-13T00:00:01.0025+00:00'

# Function to convert boolean-like columns
def convert_boolean_columns(df):
    converted_columns = []
    for column in df.columns:
        unique_vals = df.select(column).distinct().limit(100).rdd.flatMap(lambda x: x).collect()
        if set(unique_vals).issubset({"t", "f"}):
            df = df.withColumn(column, when(col(column) == "t", 1).otherwise(0))
            converted_columns.append(column)
    return df, converted_columns

# Function to convert column names to lowercase
def to_lowercase_columns(df):
    return df.select([col(c).alias(c.lower()) for c in df.columns])

# Function to align schema and cast columns to a common type
def cast_columns_to_common_type(source_df, target_df, columns):
    for col_name in columns:
        source_type = dict(source_df.dtypes).get(col_name)
        target_type = dict(target_df.dtypes).get(col_name)
        common_type = target_type if source_type != target_type else source_type
        if common_type:
            source_df = source_df.withColumn(col_name, col(col_name).cast(common_type))
            target_df = target_df.withColumn(col_name, col(col_name).cast(common_type))
    return source_df.select(columns), target_df.select(columns)

# Validation logic for a single table
def validate_table(table):
    source_sql = ""
    target_sql = ""
    post_dedup_count = 0
    comment = ""
    missing_in_source = []
    missing_in_target = []
    mismatches = []
    mismatches_target = []
    duplicate_count = 0
    source_count = 0
    target_count = 0
    target_filtered_count = 0
    target_table = ""

    try:
        source_table = f"{source_catalog}.{source_db}.{table}"
        source_df = spark.table(source_table)
        source_df, converted_boolean_columns = convert_boolean_columns(source_df)
        source_df = to_lowercase_columns(source_df)
        source_columns = set(source_df.columns)
        source_count = source_df.count()
    except Exception:
        has_createtime = False
        casted_comparison_sql = ""
            boolean_f_t_only_in_source = source_boolean_f_t_only_cols

    return {
            "source_only_count": 0,
            "target_only_count": 0,
            "input_table": table,
            "source_table": "missing",
            "target_table": "missing",
            "source_count": 0,
            "target_count": 0,
            "target_filtered_count": 0,
            "missing_in_source": [],
            "missing_in_target": [],
            "mismatches": [],
            "mismatches_target": [],
            "duplicate_check_in_target": 0,
            "source_sql": "",
            "target_sql": "",
            "post_dedup_count": 0,
            "comment": "source and target table load failure",
            "casted_comparison_sql": casted_comparison_sql
        }
        casted_comparison_sql = ""
        return {
        "converted_boolean_columns": converted_boolean_columns,
        "input_table": table,
            "source_table": "missing",
            "target_table": "missing",
            "source_count": 0,
            "target_count": 0,
            "target_filtered_count": 0,
            "missing_in_source": [],
            "missing_in_target": [],
            "mismatches": [],
            "mismatches_target": [],
            "duplicate_check_in_target": 0,
            "source_sql": "",
            "target_sql": "",
            "post_dedup_count": 0,
            "comment": "source table load failure"
        }

    prefix = table[0].lower()
    if prefix == 'p':
        target_table_name = f"policycenter_{table}"
    elif prefix == 'b':
        target_table_name = f"billingcenter_{table}"
    elif prefix == 'c':
        target_table_name = f"claimcenter_{table}"
    else:
        target_table_name = table

    try:
        target_table = f"{target_catalog}.{target_db}.{target_table_name}"
        target_df = spark.table(target_table)
        target_df = convert_boolean_columns(target_df)
        target_df = to_lowercase_columns(target_df)
        if "azure_load_date" in target_df.columns:
            target_df = target_df.drop("azure_load_date")

        target_columns = set(target_df.columns)
        has_createtime = "createtime" in target_columns
        has_updatetime = "updatetime" in target_columns

        if not (has_createtime or has_updatetime):
            target_df = target_df.dropDuplicates()
            actual_target_df = target_df.drop("azure_load_date") if "azure_load_date" in target_df.columns else target_df
            target_count = actual_target_df.count()
            target_filtered_count = target_count
        else:
            actual_target_df = target_df  # Ensure it's initialized
            target_count = actual_target_df.count()
            if has_createtime and target_count > 5000:
                target_df = target_df.filter((col("createtime") >= filter_start) & (col("createtime") <= filter_end))
            target_filtered_count = target_df.count()
    except Exception:
        return {
        "source_only_count": 0,
        "target_only_count": 0,
        "input_table": table,
        "source_table": source_table,
        "target_table": "missing",
            "source_count": source_count,
            "target_count": 0,
            "target_filtered_count": 0,
            "missing_in_source": [],
            "missing_in_target": [],
            "mismatches": [],
            "mismatches_target": [],
            "duplicate_check_in_target": 0,
            "source_sql": f"SELECT * FROM {source_table}",
            "target_sql": "",
            "post_dedup_count": 0,
            "comment": "target table load failure"
        }

    common_columns = list(source_columns & target_columns)
    source_sql = f"SELECT {', '.join(common_columns)} FROM {source_table}" if common_columns else ""
    if has_createtime and source_count > 5000:
        source_sql += f" WHERE createtime >= '{filter_start}' AND createtime <= '{filter_end}'"
    if has_createtime and target_count > 5000:
        target_sql = f"SELECT {', '.join(common_columns)} FROM {target_table} WHERE createtime >= '{filter_start}' AND createtime <= '{filter_end}'"
    else:
        target_sql = f"SELECT {', '.join(common_columns)} FROM {target_table}"

    missing_in_source = list(target_columns - source_columns)
    missing_in_target = list(source_columns - target_columns)

    source_aligned, target_aligned = cast_columns_to_common_type(source_df, target_df, common_columns)

    if not ("createtime" in target_df.columns or "updatetime" in target_df.columns):
        source_comp_df = source_aligned.dropDuplicates()
        target_comp_df = target_aligned.dropDuplicates()
    else:
        source_comp_df = source_aligned
        target_comp_df = target_aligned

    source_only = source_comp_df.subtract(target_comp_df).limit(1).count()
    target_only = target_comp_df.subtract(source_comp_df).limit(1).count()

    if source_only > 0 or target_only > 0:
        mismatches = common_columns
        mismatches_target = common_columns

    post_dedup_count = target_comp_df.count()
    dedup_cols = [c for c in actual_target_df.columns if c != "azure_load_date"]
    duplicate_count = actual_target_df.count() - actual_target_df.dropDuplicates(dedup_cols).count()

    comment_parts = []
    if source_count != post_dedup_count:
        comment_parts.append("count mismatch")
    if missing_in_source:
        comment_parts.append("missing columns in source")
    if missing_in_target:
        comment_parts.append("missing columns in target")
    if mismatches:
        comment_parts.append("data mismatch")
    if duplicate_count > 0:
        comment_parts.append("duplicates in target")
    comment = " | ".join(comment_parts) if comment_parts else "All checks passed"
    source_only_count = source_only
    target_only_count = target_only

    # Identify boolean-only columns in source
    source_boolean_f_t_only_cols = []
    for col_name in common_columns:
        try:
            source_vals = source_df.select(col_name).distinct().limit(100).rdd.flatMap(lambda x: x).collect()
            if set(map(str.lower, map(str, source_vals))).issubset({"t", "f"}):
                source_boolean_f_t_only_cols.append(col_name)
        except:
            continue

    # Prepare CAST with transformation
    cast_exprs = []
    for c in common_columns:
        if c in boolean_like_cols:
            cast_exprs.append(f"CAST(CASE LOWER({c}) WHEN 't' THEN '1' WHEN 'true' THEN '1' WHEN 'f' THEN '0' WHEN 'false' THEN '0' ELSE {c} END AS STRING) AS {c}")
        else:
            cast_exprs.append(f"CAST({c} AS STRING) AS {c}")

    casted_source_sql = f"SELECT {', '.join(cast_exprs)} FROM {source_table}"
    casted_target_sql = f"SELECT {', '.join(cast_exprs)} FROM {target_table}"
    if has_createtime and source_count > 5000:
        casted_source_sql += f" WHERE createtime >= '{filter_start}' AND createtime <= '{filter_end}'"
    if has_createtime and target_count > 5000:
        casted_target_sql += f" WHERE createtime >= '{filter_start}' AND createtime <= '{filter_end}'"
    casted_comparison_sql = casted_source_sql + " ||||| " + casted_target_sql" ||||| " + casted_target_sql
    source_only_count = source_only
    target_only_count = target_only

    return {
        "input_table": table,
        "source_table": source_table,
        "target_table": target_table,
        "source_count": source_count,
        "target_count": target_count,
        "target_filtered_count": target_filtered_count,
        "missing_in_source": missing_in_source,
        "missing_in_target": missing_in_target,
        "mismatches": mismatches,
        "mismatches_target": mismatches_target,
        "duplicate_check_in_target": duplicate_count,
        "source_sql": source_sql,
        "target_sql": target_sql,
        "post_dedup_count": post_dedup_count,
        "source_only_count": source_only_count,
        "target_only_count": target_only_count,
        "comment": comment,
        "casted_comparison_sql": casted_comparison_sql
    }

# Run validation in parallel
with ThreadPoolExecutor(max_workers=4) as executor:
    results = list(executor.map(validate_table, table_names))

schema = StructType([
    StructField("converted_boolean_columns", ArrayType(StringType()), True),
    StructField("boolean_f_t_only_in_source", ArrayType(StringType()), True),
    StructField("source_only_count", IntegerType(), True),
    StructField("target_only_count", IntegerType(), True),
    StructField("input_table", StringType(), True),
    StructField("source_table", StringType(), True),
    StructField("target_table", StringType(), True),
    StructField("source_count", IntegerType(), True),
    StructField("target_count", IntegerType(), True),
    StructField("target_filtered_count", IntegerType(), True),
    StructField("missing_in_source", ArrayType(StringType()), True),
    StructField("missing_in_target", ArrayType(StringType()), True),
    StructField("mismatches", ArrayType(StringType()), True),
    StructField("mismatches_target", ArrayType(StringType()), True),
    StructField("duplicate_check_in_target", IntegerType(), True),
    StructField("source_sql", StringType(), True),
    StructField("target_sql", StringType(), True),
    StructField("post_dedup_count", IntegerType(), True),
    StructField("comment", StringType(), True),
    StructField("casted_comparison_sql", StringType(), True)
])

result_rdd = spark.sparkContext.parallelize([(
    r["converted_boolean_columns"],
    r["source_only_count"], r["target_only_count"],
        r["input_table"], r["source_table"], r["target_table"],
    r["source_count"], r["target_count"], r["target_filtered_count"],
    r["missing_in_source"], r["missing_in_target"], r["mismatches"],
    r["mismatches_target"], r["duplicate_check_in_target"],
    r["source_sql"], r["target_sql"], r["post_dedup_count"], r["comment"], r["casted_comparison_sql"], r["boolean_f_t_only_in_source"]
) for r in results])

result_df = spark.createDataFrame(result_rdd, schema)
result_df.write.mode("overwrite").saveAsTable("core_tst_sys9.default.validation_results")
result_df.show(truncate=False)
