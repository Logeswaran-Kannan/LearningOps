from pyspark.sql import functions as F

# =========================
# CONFIGURATION
# =========================
WINDOW_HOURS = 48
WINDOW_SEC = WINDOW_HOURS * 3600

CSV_TBL    = "core_bld.radar_live.dlt_bronze_recon_athena_source"
ATHENA_TBL = "core_bld.radar_live.dlt_bronze_recon_athena_stream"
MQS_TBL    = "core_bld.radar_live.dlt_bronze_recon_mqs"


# =========================
# HELPER FUNCTIONS
# =========================
def normalize_quote_id(col):
    c = F.trim(col)
    looks_like_guid = (F.length(c) == 36) & (F.instr(c, "-") > 0)
    return (
        F.when(c.isNull() | (c == ""), None)
         .when(F.upper(c).startswith("MQS-"), c)
         .when(looks_like_guid, F.concat(F.lit("MQS-"), c))
         .otherwise(c)
    )


# =========================
# LOAD & STANDARDISE
# =========================
csv_df = (
    spark.table(CSV_TBL)
    .select(
        F.col("interactionId"),
        F.col("mqsQuoteId"),
        F.to_timestamp("requestDate").alias("request_ts")
    )
    .withColumn("requestDate", F.to_date("request_ts"))
    .withColumn("quoteId_raw", F.trim("mqsQuoteId"))
    .withColumn("quoteId_norm", normalize_quote_id("mqsQuoteId"))
    .withColumn("csv_quote_is_null", F.col("mqsQuoteId").isNull())
    .withColumn(
        "csv_quote_missing_prefix",
        (~F.col("csv_quote_is_null")) &
        (~F.upper(F.col("quoteId_raw")).startswith("MQS-"))
    )
    .withColumn("csv_row_id", F.monotonically_increasing_id())
)

ath_df = (
    spark.table(ATHENA_TBL)
    .select(
        F.col("athenaStreamInteractionId").alias("interactionId"),
        normalize_quote_id("athenaStreamMqsQuoteId").alias("quoteId_norm"),
        F.to_timestamp("athenaStreamQuoteDateTime").alias("athena_ts")
    )
)

mqs_df = (
    spark.table(MQS_TBL)
    .select(
        F.col("mQSInteractionId").alias("interactionId"),
        normalize_quote_id("mQSQuoteId").alias("quoteId_norm"),
        F.to_timestamp("mQSDateTime").alias("mqs_ts")
    )
)


# =========================
# ATHENA MATCHING
# =========================
ath_match = (
    csv_df
    .join(ath_df, ["interactionId", "quoteId_norm"], "left")
    .withColumn(
        "athena_diff_sec",
        F.abs(F.col("athena_ts").cast("long") - F.col("request_ts").cast("long"))
    )
    .groupBy("csv_row_id")
    .agg(
        F.max(F.col("athena_ts").isNotNull().cast("int")).alias("athena_present"),
        F.max((F.col("athena_diff_sec") <= WINDOW_SEC).cast("int")).alias("athena_in_window")
    )
)


# =========================
# MQS MATCHING
# =========================
mqs_match = (
    csv_df
    .join(mqs_df, ["interactionId", "quoteId_norm"], "left")
    .withColumn(
        "mqs_diff_sec",
        F.abs(F.col("mqs_ts").cast("long") - F.col("request_ts").cast("long"))
    )
    .groupBy("csv_row_id")
    .agg(
        F.max(F.col("mqs_ts").isNotNull().cast("int")).alias("mqs_present"),
        F.max((F.col("mqs_diff_sec") <= WINDOW_SEC).cast("int")).alias("mqs_in_window")
    )
)


# =========================
# FINAL INDICATOR REPORT
# =========================
final_recon = (
    csv_df
    .join(ath_match, "csv_row_id", "left")
    .join(mqs_match, "csv_row_id", "left")
    .fillna(0)
    .withColumn(
        "is_matched_both_in_window",
        ((F.col("athena_in_window") == 1) & (F.col("mqs_in_window") == 1)).cast("int")
    )
    .withColumn(
        "is_matched_both_backdated",
        ((F.col("athena_present") == 1) & (F.col("mqs_present") == 1) &
         (F.col("athena_in_window") == 0) & (F.col("mqs_in_window") == 0)).cast("int")
    )
    .withColumn(
        "is_athena_only",
        ((F.col("athena_present") == 1) & (F.col("mqs_present") == 0)).cast("int")
    )
    .withColumn(
        "is_mqs_only",
        ((F.col("athena_present") == 0) & (F.col("mqs_present") == 1)).cast("int")
    )
    .withColumn(
        "is_missing_both",
        ((F.col("athena_present") == 0) & (F.col("mqs_present") == 0)).cast("int")
    )
    .withColumn("is_csv_quote_null", F.col("csv_quote_is_null").cast("int"))
    .withColumn("is_csv_missing_prefix", F.col("csv_quote_missing_prefix").cast("int"))
    .select(
        "requestDate",
        "interactionId",
        "quoteId_raw",
        "quoteId_norm",
        "request_ts",
        "athena_present",
        "mqs_present",
        "is_matched_both_in_window",
        "is_matched_both_backdated",
        "is_athena_only",
        "is_mqs_only",
        "is_missing_both",
        "is_csv_quote_null",
        "is_csv_missing_prefix"
    )
)

final_recon.createOrReplaceTempView("recon_final_indicator_report")
